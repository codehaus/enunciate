[#ftl]
[#--
Template for a WSDL.  Assumes the existence of a variable
named "wsdl" present in the model describing the WSDL to output.
--]

[#-- assign the prefix variable for the "this" namespace --]
[#assign tns=prefix(wsdl.targetNamespace)]
[#t]
<definitions xmlns="http://schemas.xmlsoap.org/wsdl/" targetNamespace="${wsdl.targetNamespace}"
    [#list wsdl.importedNamespaces as importedNamespace]
   xmlns:${prefix(importedNamespace?default(""))}="${importedNamespace}"
    [/#list]
   xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
   xmlns:http="http://schemas.xmlsoap.org/wsdl/http/"
   xmlns:mime="http://schemas.xmlsoap.org/wsdl/mime/"
   xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
   xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/"
   xmlns:xs="http://www.w3.org/2001/XMLSchema">

  <types>
    <xs:schema targetNamespace="${wsdl.targetNamespace}">
    [#list wsdl.importedSchemas as schema]
      <xs:import namespace="${schema.namespace?default("")}"[#if schema.location?exists] schemaLocation="${schema.location}"[/#if]/>
    [/#list]

    [#--output the schema elements--]
    [@forEachEndpointInterface]
      [@forEachWebMethod]
        [@forEachWebMessage includeFaults=false]
          [#list webMessage.parts as part]
            [#if part.implicitSchemaElement]
              [#if part.typeQName?exists]
      <xs:element name="${part.elementName}" type="${part.typeQName}">
                [#if part.elementDocs?exists]
        <xs:annotation>
          <xs:documentation>
            ${part.elementDocs?trim}
          </xs:documentation>
        </xs:annotation>
                [/#if]
      </xs:element>

              [#else]
                [#assign childElements=part.childElements]
      <xs:element name="${part.elementName}">
                [#if part.elementDocs?exists]
        <xs:annotation>
          <xs:documentation>
            ${part.elementDocs?trim}
          </xs:documentation>
        </xs:annotation>
                [/#if]
                [#if childElements?size > 0]
        <xs:complexType>
          <xs:sequence>
                  [#list childElements as childElement]
            <xs:element name="${childElement.elementName}" type="${childElement.typeQName}" minOccurs="${childElement.minOccurs}" maxOccurs="${childElement.maxOccurs}">
                    [#if childElement.elementDocs?exists]
              <xs:annotation>
                <xs:documentation>
                  ${childElement.elementDocs?trim}
                </xs:documentation>
              </xs:annotation>
                    [/#if]
            </xs:element>
                  [/#list]
          </xs:sequence>
        </xs:complexType>
                [/#if]
      </xs:element>

              [/#if]
            [/#if]
          [/#list]
        [/@forEachWebMessage]
      [/@forEachWebMethod]
    [/@forEachEndpointInterface]
    [#t]
    [@forEachWebFault]
      [#if webFault.implicitSchemaElement]
        [#if webFault.typeQName?exists]
      <xs:element name="${webFault.elementName}" type="${webFault.typeQName}">
          [#if webFault.elementDocs?exists]
        <xs:annotation>
          <xs:documentation>
            ${webFault.elementDocs?trim}
          </xs:documentation>
        </xs:annotation>
          [/#if]
      </xs:element>
        [#else]
          [#assign childElements=webFault.childElements]
          [#if childElements?size > 0]
      <xs:element name="${webFault.elementName}">
          [#if webFault.elementDocs?exists]
        <xs:annotation>
          <xs:documentation>
            ${webFault.elementDocs?trim}
          </xs:documentation>
        </xs:annotation>
          [/#if]
        <xs:complexType>
          <xs:sequence>
            [#list webFault.childElements as childElement]
            <xs:element name="${childElement.elementName}" type="${childElement.typeQName}" minOccurs="${childElement.minOccurs}" maxOccurs="${childElement.maxOccurs}">
              [#if childElement.elementDocs?exists]
              <xs:annotation>
                <xs:documentation>
                  ${childElement.elementDocs?trim}
                </xs:documentation>
              </xs:annotation>
              [/#if]
            </xs:element>
            [/#list]
          </xs:sequence>
        </xs:complexType>
          [/#if]
      </xs:element>

        [/#if]
      [/#if]
    [/@forEachWebFault]
    </xs:schema>
  </types>

    [#-- output the web messages --]
    [@forEachEndpointInterface]
      [@forEachWebMethod]
        [@forEachWebMessage includeFaults=false]
  <message name="${webMessage.messageName}">
          [#if webMessage.messageDocs?exists]
    <wsdl:documentation>
      ${webMessage.messageDocs?trim}
    </wsdl:documentation>
          [/#if]
          [#list webMessage.parts as part]
    <part name="${part.partName}" element="${part.elementQName}">
            [#if part.partDocs?exists]
      <wsdl:documentation>
        ${part.partDocs?trim}
      </wsdl:documentation>
            [/#if]
    </part>
          [/#list]
  </message>
        [/@forEachWebMessage]
      [/@forEachWebMethod]
    [/@forEachEndpointInterface]
    [#t]
    [#--output the web faults globally.--]
    [@forEachWebFault]
  <message name="${webFault.messageName}">
      [#if webFault.messageDocs?exists]
    <wsdl:documentation>
      ${webMesssage.messageDocs?trim}
    </wsdl:documentation>
      [/#if]
    <part name="${webFault.partName}" element="${webFault.elementQName}"/>
  </message>
    [/@forEachWebFault]

    [#--
    example:
    <portType name="PersonService">
      <operation name="getPerson">
        <input message="tns:getPerson"/>
        <output message="tns:getPersonResponse"/>
        <fault name="PersonNotFoundException" message="tns:PersonNotFoundException"/>
      </operation>
      <operation name="findPersons">
        <input message="tns:findPersons"/>
        <output message="tns:findPersonsResponse"/>
        <fault name="PersonNotFoundException" message="tns:PersonNotFoundException"/>
      </operation>
    </portType>
    --]
    [@forEachEndpointInterface]
  <portType name="${endpointInterface.portTypeName}">
      [#if endpointInterface.docComment?exists]
    <wsdl:documentation>
      ${endpointInterface.javaDoc?trim}
    </wsdl:documentation>
      [/#if]
      [@forEachWebMethod]
    <operation name="${webMethod.operationName}">
        [#if webMethod.docComment?exists]
      <wsdl:documentation>
        ${webMethod.javaDoc?trim}
      </wsdl:documentation>
        [/#if]
        [@forEachWebMessage var="input" includeHeaders=false includeFaults=false includeOutput=false includeInput=true]
      <input message="${tns}:${input.messageName}"/>
        [/@forEachWebMessage]
        [@forEachWebMessage var="output" includeHeaders=false includeFaults=false includeOutput=true includeInput=false]
      <output message="${tns}:${output.messageName}"/>
        [/@forEachWebMessage]
        [@forEachThrownWebFault var="fault"]
      <fault message="${tns}:${fault.partName}"/>
        [/@forEachThrownWebFault]
    </operation>
      [/@forEachWebMethod]
  </portType>
    [/@forEachEndpointInterface]
    [#t]

    [#--
    example:
    <binding name="PersonServiceBinding" type="tns:PersonService">
      <soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/>
      <operation name="getPerson">
        <soap:operation soapAction=""/>
        <input>
          <soap:body use="literal"/>
        </input>
        <output>
          <soap:body use="literal"/>
        </output>
        <fault name="PersonNotFoundException">
          <soap:fault name="PersonNotFoundException" use="literal"/>
        </fault>
      </operation>
      <operation name="findPersons">
        <soap:operation soapAction=""/>
        <input>
          <soap:body use="literal"/>
        </input>
        <output>
          <soap:body use="literal"/>
        </output>
        <fault name="PersonNotFoundException">
          <soap:fault name="PersonNotFoundException" use="literal"/>
        </fault>
      </operation>
    </binding>
    --]
    [@forEachEndpointInterface]
      [@forEachBindingType]
        [#if bindingType.soap11 || bindingType.soap12]

  <binding name="${endpointInterface.getBindingNameFor(bindingType)}" type="${tns}:${endpointInterface.portTypeName}">
    <wsdl:documentation>
      SOAP Binding for ${endpointInterface.portTypeName}
    </wsdl:documentation>
    <soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="${endpointInterface.soapBindingStyle?lower_case}"/>
          [@forEachWebMethod]
    <operation name="${webMethod.operationName}">
      <soap:operation soapAction="${webMethod.action}" style="${webMethod.soapBindingStyle?lower_case}"/>
      <input>
            [@forEachWebMessage var="message" includeFaults=false includeOutput=false]
              [#if message.header]
        <soap:header message="${tns}:${message.messageName}" part="${message.partName}"/>
              [/#if]
            [/@forEachWebMessage]
        [#-- todo: figure out if this element is valid even if there isn't a body. --]
        <soap:body use="literal"/>
      </input>
      <output>
            [@forEachWebMessage var="message" includeFaults=false includeInput=false]
              [#if message.header]
        <soap:header message="${tns}:${message.messageName}" part="${message.partName}"/>
              [/#if]
            [/@forEachWebMessage]
        [#-- todo: figure out if this element is valid even if there isn't a body. --]
        <soap:body use="literal"/>
      </output>
            [@forEachThrownWebFault]
      <fault>
        <soap:fault name="${webFault.messageName}" use="literal"/>
      </fault>
            [/@forEachThrownWebFault]
    </operation>
          [/@forEachWebMethod]
  </binding>
        [#elseif bindingType.http]

  <binding name="${endpointInterface.getBindingNameFor(bindingType)}" type="${tns}:${endpointInterface.portTypeName}">
    <wsdl:documentation>
      HTTP Binding for ${endpointInterface.portTypeName}
    </wsdl:documentation>
    <http:binding verb="POST"/>
          [@forEachWebMethod]
    <operation name="${webMethod.operationName}">
      <http:operation location="TBD"/>
      <input>
        <http:urlEncoded/>
      </input>
      <output>
        <http:urlEncoded/>
      </output>
    </operation>
  </binding>
          [/@forEachWebMethod]
        [#else]
          [#stop "unknown binding type: " + bindingType.namespace]
        [/#if]
      [/@forEachBindingType]
    [/@forEachEndpointInterface]

    [#--
    example:
    <service name="PersonServiceService">
      <port name="PersonService" binding="tns:PersonServiceBinding">
        <soap:address location="REPLACE_WITH_ACTUAL_URL"/>
      </port>
    </service>
    --]
    [@forEachEndpointInterface]
  <service name="${endpointInterface.serviceName}">
      [@forEachBindingType]
    <port name="${endpointInterface.getPortNameFor(bindingType)}" binding="${tns}:${endpointInterface.getBindingNameFor(bindingType)}">
        [#if bindingType.soap11 || bindingType.soap12]
      <soap:address location="TBD"/>
        [#elseif bindingType.http]
      <http:address location="TBD"/>
        [/#if]
    </port>
      [/@forEachBindingType]
  </service>
    [/@forEachEndpointInterface]
</definitions>