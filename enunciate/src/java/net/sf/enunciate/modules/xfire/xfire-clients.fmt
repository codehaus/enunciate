[#ftl]

[#--
  library for processing client stubs
--]

[#macro processEndpointInterface endpointInterface]
// Generated by Enunciate
package ${clientPackageFor(endpointInterface)};

[#--todo: list the imports instead of referencing the fqns all the time?--]
/**
 * ${endpointInterface.docComment?default("(no documentation provided)")?chop_linebreak?replace("\n", "\n * ")}
 */
public interface ${endpointInterface.simpleName} {
  [@forEachWebMethod]

  /**
   * ${webMethod.docComment?default("(no documentation provided)")?chop_linebreak?replace("\n", "\n   * ")}
   */
  ${clientClassnameFor(webMethod.returnType)} ${webMethod.simpleName}([#list webMethod.webParameters as param]${clientClassnameFor(param.type)} ${param.simpleName}[#if param_has_next], [/#if][/#list]) [#if webMethod.webFaults?size > 0]throws [#list webMethod.webFaults as fault]${clientClassnameFor(fault)}[#if fault_has_next], [/#if][/#list][/#if];
  [/@forEachWebMethod]

}
[/#macro]

[#macro processFault fault]
// Generated by Enunciate
package ${clientPackageFor(fault)};

[#--todo: list the imports instead of referencing the fqns all the time?--]
/**
 * ${fault.docComment?default("(no documentation provided)")?chop_linebreak?replace("\n", "\n * ")}
 */
public class ${fault.simpleName} extends Exception {
  [#if fault.explicitFaultBean?exists]
    [#assign faultBean=fault.explicitFaultBean/]

  private ${clientClassnameFor(faultBean)} faultInfo;

  public ${fault.simpleName}(String message, ${clientClassnameFor(faultBean)} faultInfo)) {
    super(message);

    this.faultInfo = faultInfo;
  }

  public ${fault.simpleName}(String message, ${clientClassnameFor(faultBean)} faultInfo), Throwable cause) {
    super(message, cause);

    this.faultInfo = faultInfo;
  }

  public ${clientClassnameFor(faultBean)} getFaultInfo() {
    return this.faultInfo;
  }
  [#else]

  public ${fault.simpleName}(String message)) {
    super(message);
  }

  public ${fault.simpleName}(String message, Throwable cause) {
    super(message, cause);
  }
  [/#if]

}
[/#macro]

[#macro processType type]
  [#if type.simple]
    [@processSimpleType type=type/]
  [#elseif type.enum]
    [@processEnumType type=type/]
  [#elseif type.complex]
    [@processComplexType type=type/]
  [#else]
    [#stop "type definition is neither simple, complex, nor enum: " + type.class.name]
  [/#if]
[/#macro]

[#macro processSimpleType type]
// Generated by Enunciate
package ${clientPackageFor(type)};

[#--todo: list the imports instead of referencing the fqns all the time?--]
/**
 * ${type.docComment?default("(no documentation provided)")?chop_linebreak?replace("\n", "\n * ")}
 */
public final class ${type.simpleName} {

  private ${clientClassnameFor(type.value.accessorType)} ${type.value.simpleName};

  public ${type.simpleName}() {
  }

  /**
   * ${type.value.docComment?default("(no documentation provided)")?chop_linebreak?replace("\n", "\n   * ")}
   */
  public ${clientClassnameFor(type.value.accessorType)} get${type.value.simpleName?cap_first}() {
    return this.${type.value.simpleName};
  }

  /**
   * ${type.value.docComment?default("(no documentation provided)")?chop_linebreak?replace("\n", "\n   * ")}
   */
  public void set${type.value.simpleName?cap_first}(${clientClassnameFor(type.value.accessorType)} ${type.value.simpleName}) {
    this.${type.value.simpleName} = ${type.value.simpleName};
  }

}
[/#macro]

[#macro processEnumType type]
// Generated by Enunciate
package ${clientPackageFor(type)};

[#--todo: list the imports instead of referencing the fqns all the time?--]
/**
 * ${type.docComment?default("(no documentation provided)")?chop_linebreak?replace("\n", "\n * ")}
 */
public enum ${type.simpleName} {
  [#list type.delegate.enumConstants as constant]

  /**
   * ${constant.docComment?default("(no documentation provided)")?chop_linebreak?replace("\n", "\n   * ")}
   */
  ${constant.simpleName}[#if constant_has_next],[/#if]
  [/#list]

}
[/#macro]

[#macro processComplexType type]
// Generated by Enunciate
package ${clientPackageFor(type)};

[#--todo: list the imports instead of referencing the fqns all the time?--]
/**
 * ${type.docComment?default("(no documentation provided)")?chop_linebreak?replace("\n", "\n * ")}
 */
public [#if type.abstract]abstract [/#if][#if type.final]final [/#if]class ${type.simpleName} [#if !type.contentType.implied]extends ${clientClassnameFor(type.superclass)} [/#if]{

  [#list type.attributes as attribute]
  private ${clientClassnameFor(attribute.accessorType)} ${attribute.simpleName};
  [/#list]
  [#list type.elements as element]
  private ${clientClassnameFor(element.accessorType)} ${element.simpleName};
  [/#list]
  [#list type.attributes as attribute]

  /**
   * ${attribute.javaDoc.return?default(attribute.javaDoc)?chop_linebreak?replace("\n", "\n   * ")}
   */
  public ${clientClassnameFor(attribute.accessorType)} get${attribute.simpleName?cap_first}() {
    return this.${attribute.simpleName};
  }

  /**
   * ${attribute.javaDoc.return?default(attribute.javaDoc)?chop_linebreak?replace("\n", "\n   * ")}
   */
  public void set${attribute.simpleName?cap_first}(${clientClassnameFor(attribute.accessorType)} ${attribute.simpleName}) {
    this.${attribute.simpleName} = ${attribute.simpleName};
  }
  [/#list]
  [#list type.elements as element]

  /**
   * ${element.javaDoc.return?default(element.javaDoc)?chop_linebreak?replace("\n", "\n   * ")}
   */
  public ${clientClassnameFor(element.accessorType)} get${element.simpleName?cap_first}() {
    return this.${element.simpleName};
  }

  /**
   * ${element.javaDoc.return?default(element.javaDoc)?chop_linebreak?replace("\n", "\n   * ")}
   */
  public void set${element.simpleName?cap_first}(${clientClassnameFor(element.accessorType)} ${element.simpleName}) {
    this.${element.simpleName} = ${element.simpleName};
  }
  [/#list]

}
[/#macro]