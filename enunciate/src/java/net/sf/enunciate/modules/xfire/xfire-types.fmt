[#ftl]

[#--generate each client-side service endpoint and web fault.--]
[#--
todo: write out the types for the eis and faults?
[@forEachWsdl]
  [@forEachEndpointInterface]
    [@processEndpointInterface endpointInterface=endpointInterface/]
  [/@forEachEndpointInterface]

  [@forEachWebFault]
    [@processFault fault=webFault/]
  [/@forEachWebFault]
[/@forEachWsdl]
--]

[#--generate each client-side bean stub.--]
[@forEachSchema]
  [#list schema.typeDefinitions as typeDefinition]
    [@processType type=typeDefinition/]
  [/#list]
[/@forEachSchema]

[#--macro the processes a client-side bean stub.--]
[#macro processType type]

  [#--the java type client stub--]
  [@file name=(type.simpleName + ".java")  package=("xfire.types." + clientPackageFor(type))]
    [#if type.simple]
      [@processSimpleType type=type/]
    [#elseif type.enum]
      [@processEnumType type=type/]
    [#elseif type.complex]
      [@processComplexType type=type/]
    [#else]
      [#stop "type definition is neither simple, complex, nor enum: " + type.class.name]
    [/#if]
  [/@file]

[/#macro]

[#macro processSimpleType type]
[#assign classname=${clientClassnameFor(type)}/]
// Generated by Enunciate
package ${clientPackageFor(type)};

import org.codehaus.xfire.aegis.type.Type;
import org.codehaus.xfire.aegis.MessageReader;
import org.codehaus.xfire.aegis.MessageWriter;
import org.codehaus.xfire.MessageContext;
import org.codehaus.xfire.fault.XFireFault;

/**
 * Logic for reading and writing an instance of ${classname} to an xml stream.
 *
 * @author Ryan Heaton
 */
public class ${type.simpleName}XFireType extends Type {

  /**
   * Reads an instance of ${type.simpleName} from the value given.
   *
   * @param reader The reader to read from.
   * @param context The context.
   * @return The ${type.simpleName}.
   */
  public Object readObject(MessageReader reader, MessageContext context) throws XFireFault {
    ${classname} instance = new ${classname}();

    [#--todo: what if it's an xml list?--]
    [#--todo: what if it's a primitive?--]
    [#--todo: what if it's nillable?--]
    Type type = getTypeMapping().getType(${type.value.accessorType}.class);
    Object value = type.readObject(reader, context);
    instance.set${type.value.simpleName?cap_first}((${type.value.accessorType}) value);

    return instance;
  }

  /**
   * Writes the value for an instance of ${type.simpleName} to a writer.
   *
   * @param object The ${type.simpleName}.
   * @param writer The writer.
   * @param context The context.
   */
  public void writeObject(Object object, MessageWriter writer, MessageContext context) throws XFireFault {
    ${classname} instance = (${classname}) object;

    [#--todo: what if it's nillable?--]
    writer.writeValue(String.valueOf(instance.get${type.value.simpleName?cap_first}()));
  }
}
[/#macro]

[#macro processEnumType type]
[#assign classname=${clientClassnameFor(type)}/]
// Generated by Enunciate
package ${clientPackageFor(type)};

import org.codehaus.xfire.aegis.type.Type;
import org.codehaus.xfire.aegis.MessageReader;
import org.codehaus.xfire.aegis.MessageWriter;
import org.codehaus.xfire.MessageContext;
import org.codehaus.xfire.fault.XFireFault;

/**
 * Reads and writes an instance of ${classname} to/from an XML stream.
 *
 * @author Ryan Heaton
 */
public class ${type.simpleName}XFireType extends Type {

  /**
   * Reads an instance of ${type.simpleName} from an XML stream.
   *
   * @param reader The reader.
   * @param context The context.
   * @return The instance.
   */
  public Object readObject(MessageReader reader, MessageContext context) throws XFireFault {
    String value = reader.getValue();

    [#assign enumValueMap=type.enumValues/]
    [#list enumValueMap?keys as enumConstant]
    [#if !enumConstant_first]else [/#if]if ("${enumValueMap[enumConstant]}".equals(value)) {
      return ${classname}.${enumConstant.simpleName};
    }
    [#list]

    throw new IllegalArgumentException("Unknown ${type.simpleName}: " + value);
  }

  /**
   * Writes an instance of ${type.simpleName} to an XML stream.
   *
   * @param object instance.
   * @param writer The writer.
   * @param context The context.
   */
  public void writeObject(Object object, MessageWriter writer, MessageContext context) throws XFireFault {
    switch ((${classname}) object) {
    [#assign enumValueMap=type.enumValues/]
    [#list enumValueMap?keys as enumConstant]
      case ${enumConstant.simpleName}:
        writer.writeValue("${enumValueMap[enumConstant]}");
        return;
    [#list]
    }

    throw new IllegalArgumentException("No constant value known for ${type.simpleName}." + object);
  }
}
[/#macro]

[#macro processComplexType type]
// Generated by Enunciate
package ${clientPackageFor(type)};

[/#macro]