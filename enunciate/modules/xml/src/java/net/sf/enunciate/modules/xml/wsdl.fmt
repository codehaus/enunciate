[#ftl]
[#--
Template library for WSDL.
--]

[#--
  The processWsdl macro outputs a given WSDL.

  @param wsdl The WSDL to output.  (Instance of net.sf.enunciate.config.WsdlInfo)
--]
[#macro processWsdl wsdl]
[#-- assign the prefix variable for the "this" namespace --]
[#assign tns=prefix(wsdl.targetNamespace)]
[#-- assign the prefix variable for the "wsdl" namespace --]
[#assign wsdl=prefix("http://schemas.xmlsoap.org/wsdl/")]
[#-- assign the prefix variable for the "http" namespace --]
[#assign http=prefix("http://schemas.xmlsoap.org/wsdl/http/")]
[#-- assign the prefix variable for the "mime" namespace --]
[#assign mime=prefix("http://schemas.xmlsoap.org/wsdl/mime/")]
[#-- assign the prefix variable for the "soap" namespace --]
[#assign soap=prefix("http://schemas.xmlsoap.org/wsdl/soap/")]
[#-- assign the prefix variable for the "soapenc" namespace --]
[#assign soapenc=prefix("http://schemas.xmlsoap.org/soap/encoding/")]
[#-- assign the prefix variable for the schema namespace --]
[#assign xs=prefix("http://www.w3.org/2001/XMLSchema")]
[#t]
<?xml version="1.0" encoding="UTF-8"?>
<definitions xmlns="http://schemas.xmlsoap.org/wsdl/" targetNamespace="${wsdl.targetNamespace}"
    [#list wsdl.importedNamespaces as importedNamespace]
      [#if importedNamespace?exists && importedNamespace?length > 0]
   xmlns:${prefix(importedNamespace)}="${importedNamespace}"
      [/#if]
    [/#list]
   >

  <types>
    [@processSchema wsdl=wsdl/]
  </types>

    [#-- output the web messages --]
    [@forEachWebMessage]
      [@processMessage webMessage=webMessage/]
    [/@forEachWebMessage]

    [@forEachEndpointInterface]
      [@processPortType endpointInterface=endpointInterface/]
    [/@forEachEndpointInterface]
    [#t]

    [@forEachEndpointInterface]
      [@processBindings endpointInterface=endpointInterface/]
    [/@forEachEndpointInterface]

    [@forEachEndpointInterface]
      [@processServices endpointInterface=endpointInterface/]
    [/@forEachEndpointInterface]
</definitions>
[/#macro]

[#--
  The processSchema macro outputs a schema element for a specified wsdl.

  @param wsdl The WSDL to output.  (Instance of net.sf.enunciate.config.WsdlInfo)
--]
[#macro processSchema wsdl]
  <${xs}:schema targetNamespace="${wsdl.targetNamespace}">
  [#list wsdl.importedSchemas as schema]
    <${xs}:import namespace="${schema.namespace?default("")}"[#if schema.location?exists] schemaLocation="${schema.location}"[/#if]/>
  [/#list]

  [#--output the schema elements--]
  [@forEachWebMessage]
    [#list webMessage.parts as part]
      [#if part.implicitSchemaElement]
        [#if part.typeQName?exists]
    <${xs}:element name="${part.elementName}" type="${part.typeQName}">
          [#if part.elementDocs?exists]
      <${xs}:annotation>
        <${xs}:documentation>
          ${part.elementDocs?trim}
        </${xs}:documentation>
      </${xs}:annotation>
          [/#if]
    </${xs}:element>

        [#else]
          [#assign childElements=part.childElements]
    <${xs}:element name="${part.elementName}">
          [#if part.elementDocs?exists]
      <${xs}:annotation>
        <${xs}:documentation>
          ${part.elementDocs?trim}
        </${xs}:documentation>
      </${xs}:annotation>
          [/#if]
          [#if childElements?size > 0]
      <${xs}:complexType>
        <${xs}:sequence>
            [#list childElements as childElement]
          <${xs}:element name="${childElement.elementName}" type="${childElement.typeQName}" minOccurs="${childElement.minOccurs}" maxOccurs="${childElement.maxOccurs}">
              [#if childElement.elementDocs?exists]
            <${xs}:annotation>
              <${xs}:documentation>
                ${childElement.elementDocs?trim}
              </${xs}:documentation>
            </${xs}:annotation>
              [/#if]
          </${xs}:element>
            [/#list]
        </${xs}:sequence>
      </${xs}:complexType>
          [/#if]
    </${xs}:element>

        [/#if]
      [/#if]
    [/#list]
  [/@forEachWebMessage]
  </${xs}:schema>
[/#macro]

[#--
  The processMessage macro outputs a message element for a specified web message.

  @param webMessage The web message to output.  (Instance of net.sf.enunciate.contract.jaxws.WebMessage)
--]
[#macro processMessage webMessage]
  <message name="${webMessage.messageName}">
      [#if webMessage.messageDocs?exists]
    <documentation>
      ${webMessage.messageDocs?trim}
    </documentation>
      [/#if]
      [#list webMessage.parts as part]
    [#--todo: support encoded style? nah...--]
    <part name="${part.partName}" ${part.particleType?lower_case}="${part.particleQName}">
        [#if part.partDocs?exists]
      <documentation>
        ${part.partDocs?trim}
      </documentation>
        [/#if]
    </part>
      [/#list]
  </message>
[/#macro]

[#--
  The processPortType macro outputs a portType element for a specified endpoint interface.

  @param endpointInterface The endpoint interface to output.  (Instance of net.sf.enunciate.contract.jaxws.EndpointInterface)
--]
[#macro processPortType endpointInterface]
  <portType name="${endpointInterface.portTypeName}">
      [#if endpointInterface.docComment?exists]
    <documentation>
      ${endpointInterface.javaDoc?trim}
    </documentation>
      [/#if]
      [@forEachWebMethod]
        [@processOperation webMethod=webMethod/]
      [/@forEachWebMethod]
  </portType>
[/#macro]

[#--
  The processOperation macro outputs an operation element for a web method.

  @param webMethod The web method to output.  (Instance of net.sf.enunciate.contract.jaxws.WebMethod)
--]
[#macro processOperation webMethod]
  <operation name="${webMethod.operationName}">
      [#if webMethod.docComment?exists]
    <documentation>
      ${webMethod.javaDoc?trim}
    </documentation>
      [/#if]
      [@forEachWebMessage var="input" includeHeaders=false includeFaults=false includeOutput=false includeInput=true]
    <input message="${tns}:${input.messageName}"/>
      [/@forEachWebMessage]
      [@forEachWebMessage var="output" includeHeaders=false includeFaults=false includeOutput=true includeInput=false]
    <output message="${tns}:${output.messageName}"/>
      [/@forEachWebMessage]
      [@forEachThrownWebFault var="fault"]
    <fault name="${fault.partName}" message="${tns}:${fault.messageName}"/>
      [/@forEachThrownWebFault]
  </operation>
[/#macro]

[#--
  The processBindings macro outputs a all binding elements for a specified endpoint interface.

  @param endpointInterface The endpoint interface to output.  (Instance of net.sf.enunciate.contract.jaxws.EndpointInterface)
--]
[#macro processBindings endpointInterface]
  [@forEachBindingType]
    [#if bindingType.soap11 || bindingType.soap12]

      [@processSOAPBinding endpointInterface=endpointInterface/]
    [#elseif bindingType.http]

      [@processHTTPBinding endpointInterface=endpointInterface/]
    [#else]
      [#stop "unknown binding type: " + bindingType.namespace]
    [/#if]
  [/@forEachBindingType]
[/#macro]

[#--
  The processSOAPBinding macro outputs a soap binding element for a specified endpoint interface.

  @param endpointInterface The endpoint interface to output.  (Instance of net.sf.enunciate.contract.jaxws.EndpointInterface)
--]
[#macro processSOAPBinding endpointInterface]
  <binding name="${endpointInterface.simpleName}SOAPBinding" type="${tns}:${endpointInterface.portTypeName}">
    <documentation>
      SOAP Binding for ${endpointInterface.portTypeName}
    </documentation>
    <${soap}:binding transport="http://schemas.xmlsoap.org/soap/http" style="${endpointInterface.soapBindingStyle?lower_case}"/>
      [@forEachWebMethod]
    <operation name="${webMethod.operationName}">
      <${soap}:operation soapAction="${webMethod.action}" style="${webMethod.soapBindingStyle?lower_case}"/>
      <input>
        [@forEachWebMessage var="message" includeFaults=false includeOutput=false]
          [#if message.header]
        <${soap}:header message="${tns}:${message.messageName}" part="${message.partName}"/>
          [/#if]
        [/@forEachWebMessage]
        [#-- todo: figure out if this element is valid even if there isn't a body. --]
        <${soap}:body use="literal"/>
      </input>
      <output>
        [@forEachWebMessage var="message" includeFaults=false includeInput=false]
          [#if message.header]
        <${soap}:header message="${tns}:${message.messageName}" part="${message.partName}"/>
          [/#if]
        [/@forEachWebMessage]
        [#-- todo: figure out if this element is valid even if there isn't a body. --]
        <${soap}:body use="literal"/>
      </output>
        [@forEachThrownWebFault]
      <fault>
        <${soap}:fault name="${webFault.messageName}" use="literal"/>
      </fault>
        [/@forEachThrownWebFault]
    </operation>
      [/@forEachWebMethod]
  </binding>
[/#macro]

[#--
  The processHTTPBinding macro outputs an HTTP binding element for a specified endpoint interface.

  @param endpointInterface The endpoint interface to output.  (Instance of net.sf.enunciate.contract.jaxws.EndpointInterface)
--]
[#macro processHTTPBinding endpointInterface]
  <binding name="${endpointInterface.simpleName}HTTPBinding" type="${tns}:${endpointInterface.portTypeName}">
    <documentation>
      HTTP Binding for ${endpointInterface.portTypeName}
    </documentation>
    <${http}:binding verb="POST"/>
      [@forEachWebMethod]
    <operation name="${webMethod.operationName}">
      <${http}:operation location="TBD"/>
      <input>
        <${http}:urlEncoded/>
      </input>
      <output>
        <${http}:urlEncoded/>
      </output>
    </operation>
      [/@forEachWebMethod]
  </binding>
[/#macro]

[#--
  The processServices macro outputs the service element for a specified endpoint interface.

  @param endpointInterface The endpoint interface to output.  (Instance of net.sf.enunciate.contract.jaxws.EndpointInterface)
--]
[#macro processServices endpointInterface]
  <service name="${endpointInterface.serviceName}">
      [@forEachBindingType]
        [#if bindingType.soap11 || bindingType.soap12]
          [@processSOAPServicePort endpointInterface=endpointInterface/]
        [#elseif bindingType.http]
          [@processHTTPServicePort endpointInterface=endpointInterface/]
        [/#if]
      [/@forEachBindingType]
  </service>
[/#macro]

[#--
  The processSOAPServicePort macro outputs a soap port element for a specified endpoint interface.

  @param endpointInterface The endpoint interface to output.  (Instance of net.sf.enunciate.contract.jaxws.EndpointInterface)
--]
[#macro processSOAPServicePort endpointInterface]
    <port name="${endpointInterface.simpleName}SOAPPort" binding="${tns}:${endpointInterface.simpleName}SOAPBinding">
      [#--todo: make this address a known token so the server-side code can process it.--]
      [#--todo: add an option to state this address statically.--]
      <${soap}:address location="TBD"/>
    </port>
[/#macro]

[#--
  The processHTTPServicePort macro outputs a http port element for a specified endpoint interface.

  @param endpointInterface The endpoint interface to output.  (Instance of net.sf.enunciate.contract.jaxws.EndpointInterface)
--]
[#macro processHTTPServicePort endpointInterface]
    <port name="${endpointInterface.simpleName}HTTPPort" binding="${tns}:${endpointInterface.simpleName}HTTPBinding">
      [#--todo: make this address a known token so the server-side code can process it.--]
      [#--todo: add an option to state this address statically.--]
      <${http}:address location="TBD"/>
    </port>
[/#macro]