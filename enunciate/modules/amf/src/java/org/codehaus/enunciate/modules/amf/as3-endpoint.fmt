[#ftl]
[#--template for the client-side endpoint interface.--]
[@file name=(endpointInterface.simpleName + ".as")  package=endpointInterface.package.qualifiedName]
// Generated by Enunciate
package ${endpointInterface.package.qualifiedName} {

  import flash.events.EventDispatcher;
  import mx.rpc.remoting.RemoteObject;
  import mx.rpc.events.ResultEvent;
  import mx.rpc.events.FaultEvent;
  import flash.net.registerClassAlias;
  [@forEachAMFImport declaration=endpointInterface]
  import ${amfImport};
  [/@forEachAMFImport]
  import ${endpointInterface.qualifiedName}.*;

  /**
   * ${endpointInterface.docComment?default("(no documentation provided)")?chop_linebreak?replace("\n", "\n   * ")}
   */
  [@forEachWebMethod endpointInterface=endpointInterface]
    [#if !webMethod.annotations["org.codehaus.enunciate.modules.amf.AMFTransient"]?exists]
  [Event(name="${webMethod.operationName}", type="${endpointInterface.qualifiedName}.${webMethod.operationName?cap_first}ResultEvent")]
    [/#if]
  [/@forEachWebMethod]
  [Event(name="fault", type="mx.rpc.events.FaultEvent")]
  public class ${endpointInterface.simpleName} extends EventDispatcher {

    private var _requestTimeout:int = 0;

    /**
     * The request timeout, in seconds.
     */
    public function get requestTimeout():int {
      return _requestTimeout;
    }

    /**
     * The request timeout.
     *
     * @param timeout The timeout, in seconds.
     */
    public function set requestTimeout(timeout:int):void {
      _requestTimeout = timeout;
    }

    /**
     * Delegates a fault event.
     *
     * @param event The fault event.
     */
    private function handleFault(event:FaultEvent):void {
      dispatchEvent(event);
    }

    [@forEachWebMethod endpointInterface=endpointInterface]
      [#if !webMethod.annotations["org.codehaus.enunciate.modules.amf.AMFTransient"]?exists]

    /**
     * ${webMethod.docComment?default("(no documentation provided)")?chop_linebreak?replace("\n", "\n     * ")}
     */
    public function ${webMethod.simpleName}([#list webMethod.webParameters as param]${param.simpleName}:${classnameFor(param)}[#if param_has_next], [/#if][/#list]):void {
      [#if webMethod.returnType.map?default(false)]
        [#if webMethod.returnType.keyType.declared && as3Aliases[webMethod.returnType.keyType.declaration.qualifiedName]?exists]
      //register the type for the key type of the key-value pairs that are returned.
      registerClassAlias("${webMethod.returnType.keyType.declaration.qualifiedName}", ${as3Aliases[webMethod.returnType.keyType.declaration.qualifiedName]});
        [/#if]
        [#if webMethod.returnType.valueType.declared && as3Aliases[webMethod.returnType.valueType.declaration.qualifiedName]?exists]
      //register the type for the value type of the key-value pairs that are returned.
      registerClassAlias("${webMethod.returnType.valueType.declaration.qualifiedName}", ${as3Aliases[webMethod.returnType.valueType.declaration.qualifiedName]});
        [/#if]
      [#elseif webMethod.returnType.collection || webMethod.returnType.array]
        [#if as3Aliases[componentTypeFor(webMethod.returnType)]?exists]
      //register the item type of the collection that is returned.
      registerClassAlias("${componentTypeFor(webMethod.returnType)}", ${as3Aliases[componentTypeFor(webMethod.returnType)]});
        [/#if]
      [/#if]
      var ro:RemoteObject = new RemoteObject();
      ro.requestTimeout = _requestTimeout;
      ro.destination = "${endpointInterface.simpleName}";
      ro.addEventListener("result", handle${webMethod.simpleName?cap_first}Result);
      ro.addEventListener("fault", handleFault);
      ro.${webMethod.simpleName}([#list webMethod.webParameters as param]${param.simpleName}[#if param_has_next], [/#if][/#list]);
    }

    private function handle${webMethod.simpleName?cap_first}Result(event:ResultEvent):void {
      dispatchEvent(new ${webMethod.operationName?cap_first}ResultEvent([#if !webMethod.returnType.void]${classnameFor(webMethod.webResult)}(event.result)[/#if]));
    }
      [/#if]
    [/@forEachWebMethod]
  }
}
[/@file]
[#--todo: generate the MXML remote object for Flex?--]
[@forEachWebMethod endpointInterface=endpointInterface]
  [#if !webMethod.annotations["org.codehaus.enunciate.modules.amf.AMFTransient"]?exists]
    [@file name="${webMethod.operationName?cap_first}ResultEvent.as"  package=endpointInterface.qualifiedName]
// Generated by Enunciate
package ${endpointInterface.qualifiedName} {

  import flash.events.Event;
  [@forEachAMFImport declaration=webMethod includeComponentTypes=false]
  import ${amfImport};
  [/@forEachAMFImport]

  /**
   * Event triggered when a response is recieved.
   */
  public class ${webMethod.operationName?cap_first}ResultEvent extends Event {

      [#if !webMethod.returnType.void]
    private var _result:${classnameFor(webMethod.webResult)};

      [/#if]
    /**
     * Construct a result event.
     */
    public function ${webMethod.operationName?cap_first}ResultEvent([#if !webMethod.returnType.void]result:${classnameFor(webMethod.webResult)}[/#if]) {
      super("${webMethod.operationName}");
      [#if !webMethod.returnType.void]
      this._result = result;
      [/#if]
    }

      [#if !webMethod.returnType.void]
    /**
     * The result.
     */
    public function get result():${classnameFor(webMethod.webResult)} {
      return _result;
    }

      [/#if]
    override public function clone():Event {
      return new ${webMethod.operationName?cap_first}ResultEvent([#if !webMethod.returnType.void]this._result[/#if]);
    }
  }
}
    [/@file]
  [/#if]
[/@forEachWebMethod]
