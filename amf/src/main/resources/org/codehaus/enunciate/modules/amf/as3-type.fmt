[#ftl]
[#--template for the client-side complex type.--]
[@file name=(simpleNameFor(type) + ".as") package=packageFor(type) charset="utf-8"]
[#assign baseobject=type.baseObject/]
// Generated by Enunciate
package ${packageFor(type)} {

  import flash.utils.IExternalizable;
  import flash.utils.IDataOutput;
  import flash.utils.IDataInput;
  import flash.net.registerClassAlias;
  [@forEachAS3Import declaration=type]
  import ${as3Import};
  [/@forEachAS3Import]

  [#list type.attributes as attribute]
    [#if attribute.accessorType.map?default(false)]
      [#if as3Aliases[amfClassnameFor(attribute.accessorType.keyType)]?exists]
  //register the type for the key type of the key-value pairs for the "${attribute.simpleName}" property.
  registerClassAlias("${amfClassnameFor(attribute.accessorType.keyType)}", ${as3Aliases[amfClassnameFor(attribute.accessorType.keyType)]});
      [/#if]
      [#if as3Aliases[amfClassnameFor(attribute.accessorType.valueType)]?exists]
  //register the type for the value type of the key-value pairs for the "${attribute.simpleName}" property.
  registerClassAlias("${amfClassnameFor(attribute.accessorType.valueType)}", ${as3Aliases[amfClassnameFor(attribute.accessorType.valueType)]});
      [/#if]
    [#elseif attribute.accessorType.collection || attribute.accessorType.array]
      [#if as3Aliases[amfComponentTypeFor(attribute.accessorType)]?exists]
  //register the item type of the collection for the "${attribute.simpleName}" property.
  registerClassAlias("${amfComponentTypeFor(attribute.accessorType)}", ${as3Aliases[amfComponentTypeFor(attribute.accessorType)]});
      [/#if]
    [/#if]
  [/#list]
  [#if type.value?exists]
    [#if type.value.accessorType.map?default(false)]
      [#if as3Aliases[amfClassnameFor(type.value.accessorType.keyType)]?exists]
  //register the type for the key type of the key-value pairs for the "${type.value.simpleName}" property.
  registerClassAlias("${amfClassnameFor(type.value.accessorType.keyType)}", ${as3Aliases[amfClassnameFor(type.value.accessorType.keyType)]});
      [/#if]
      [#if as3Aliases[amfClassnameFor(type.value.accessorType.valueType)]?exists]
  //register the type for the value type of the key-value pairs for the "${type.value.simpleName}" property.
  registerClassAlias("${amfClassnameFor(type.value.accessorType.valueType)}", ${as3Aliases[amfClassnameFor(type.value.accessorType.valueType)]});
      [/#if]
    [#elseif type.value.accessorType.collection || type.value.accessorType.array]
      [#if as3Aliases[amfComponentTypeFor(type.value.accessorType)]?exists]
  //register the item type of the collection for the "${type.value.simpleName}" property.
  registerClassAlias("${amfComponentTypeFor(type.value.accessorType)}", ${as3Aliases[amfComponentTypeFor(type.value.accessorType)]});
      [/#if]
    [/#if]
  [#else]
    [#list type.elements as element]
      [#if element.accessorType.map?default(false)]
        [#if as3Aliases[amfClassnameFor(element.accessorType.keyType)]?exists]
  //register the type for the key type of the key-value pairs for the "${element.simpleName}" property.
  registerClassAlias("${amfClassnameFor(element.accessorType.keyType)}", ${as3Aliases[amfClassnameFor(element.accessorType.keyType)]});
        [/#if]
        [#if as3Aliases[amfClassnameFor(element.accessorType.valueType)]?exists]
  //register the type for the value type of the key-value pairs for the "${element.simpleName}" property.
  registerClassAlias("${amfClassnameFor(element.accessorType.valueType)}", ${as3Aliases[amfClassnameFor(element.accessorType.valueType)]});
        [/#if]
      [#elseif element.accessorType.collection || element.accessorType.array]
        [#if as3Aliases[amfComponentTypeFor(element.accessorType)]?exists]
  //register the item type of the collection for the "${element.simpleName}" property.
  registerClassAlias("${amfComponentTypeFor(element.accessorType)}", ${as3Aliases[amfComponentTypeFor(element.accessorType)]});
        [/#if]
      [/#if]
    [/#list]
  [/#if]

  /**
   * ${type.docComment?default("(no documentation provided)")?chop_linebreak?replace("\n", "\n   * ")}
   */
  [Bindable]
  [RemoteClass(alias="${amfClassnameFor(type)}")]
  public [#if type.final]final [/#if]class ${simpleNameFor(type)} [#if !baseobject]extends ${classnameFor(type.superclass)} [/#if]{

  [#list type.attributes as attribute]
    private var _${attribute.simpleName}:${classnameFor(attribute)};
  [/#list]
  [#if type.value?exists]
    private var _${type.value.simpleName}:${classnameFor(type.value)};
  [#else]
    [#list type.elements as element]
    private var _${element.simpleName}:${classnameFor(element)};
    [/#list]
  [/#if]

    public function ${type.clientSimpleName}() {
    }
  [#list type.attributes as attribute]
[@propertyAccessors property=attribute/]
  [/#list]
  [#if type.value?exists]
[@propertyAccessors property=type.value/]
  [#else]
    [#list type.elements as element]
[@propertyAccessors property=element/]
    [/#list]
  [/#if]
  }
}
[/@file]
[#macro propertyAccessors property]
  [#if !property.annotations["org.codehaus.enunciate.modules.amf.AMFTransient"]?exists]
    [#assign accessorOverrides=accessorOverridesAnother(property)/]

    /**
     * ${property.javaDoc.return?default(property.docValue?default("(no documentation provided)"))?chop_linebreak?replace("\n", "\n     * ")}
     */
    public [#if accessorOverrides]override [/#if]function get ${property.simpleName}():${classnameFor(property)} {
      return _${property.simpleName};
    }

    /**
     * ${property.javaDoc.return?default(property.docValue?default("(no documentation provided)"))?chop_linebreak?replace("\n", "\n     * ")}
     */
    public [#if accessorOverrides]override [/#if]function set ${property.simpleName}(${property.simpleName}:${classnameFor(property)}):void {
      _${property.simpleName} = ${property.simpleName};
    }
  [/#if]
[/#macro]